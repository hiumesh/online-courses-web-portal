-- types

create type course_level_enum as enum ('ALL_LEVELS', 'BEGINNER', 'INTERMEDIATE', 'EXPERT');
create type course_access_enum as enum ('PAID', 'FREE');
create type language_enum AS enum ('English', 'Hindi', 'Sanskrit', 'Spanish', 'French', 'German', 'Italian', 'Japanese', 'Chinese', 'Russian', 'Other');

-- tables

create table
  public.user_profile (
    user_id uuid not null,
    username text not null,
    avatar text null,
    first_name text null,
    last_name text null,
    account_type text not null default 'default'::text,
    constraint user_profile_pkey primary key (user_id),
    constraint user_profile_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.category (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    created_at timestamp with time zone null default now(),
    constraint category_pkey primary key (id),
    constraint category_name_key unique (name)
  ) tablespace pg_default;

create table
  public.sub_category (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    category_id bigint not null,
    created_at timestamp with time zone null default now(),
    constraint sub_category_pkey primary key (id),
    constraint sub_category_name_and_category_id_composite_key unique (name, category_id),
    constraint sub_category_category_id_fkey foreign key (category_id) references category (id) on delete cascade
  ) tablespace pg_default;

create table
  public.topics (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    created_at timestamp with time zone null default now(),
    constraint topics_pkey primary key (id),
    constraint topics_name_key unique (name)
  ) tablespace pg_default;


create table
  public.sub_category_topics (
    topic_id bigint not null,
    sub_category_id bigint not null,
    constraint sub_category_topics_pkey primary key(topic_id, sub_category_id),
    constraint sub_category_topics_topic_id_fkey foreign key (topic_id) references topics (id) on delete cascade,
    constraint sub_category_topics_sub_category_id_fkey foreign key (sub_category_id) references sub_category (id) on delete cascade
  ) tablespace pg_default;


create table
  public.topic_connections (
    id bigint generated by default as identity not null,
    from_id bigint not null,
    to_id bigint not null,
    constraint topic_connections_pkey primary key(id),
    constraint topic_connections_from_and_to_key unique(from_id, to_id),
    constraint topic_connections_from_id_fkey foreign key (from_id) references topics (id) on delete cascade,
    constraint topic_connections_to_id_fkey foreign key (to_id) references topics (id) on delete cascade
  ) tablespace pg_default;

create table
  public.courses (
    id bigint generated by default as identity not null,
    image text null,
    title text not null,
    short_description text null,
    category bigint not null,
    sub_category bigint not null,
    level course_level_enum default 'ALL_LEVELS' not null,
    long_description text null,
    requirements text null,
    course_purpose text null,
    language language_enum not null,
    is_paid course_access_enum default 'PAID' not null,
    course_promises json null,
    avg_rating decimal(10,2) default 0 not null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    constraint courses_pkey primary key (id),
    constraint courses_category_fkey foreign key (category) references category (id) on delete restrict,
    constraint courses_sub_category_fkey foreign key (sub_category) references sub_category (id) on delete restrict
  ) tablespace pg_default;

create table
  public.price (
    id bigint generated by default as identity not null,
    course_id bigint not null,
    amount decimal(10,2),
    currency varchar(3) default 'USD',
    is_promotional boolean default false,
    start_date date,
    end_date date,
    constraint price_pkey primary key (id),
    constraint price_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.tags (
    id bigint generated by default as identity not null,
    name text not null,
    constraint tags_pkey primary key (id),
    constraint tags_name_key unique (name)
  ) tablespace pg_default;

create table
  public.course_tags (
    tag_id bigint not null,
    course_id bigint not null,
    constraint course_tags_tag_id_fkey foreign key (tag_id) references tags (id) on delete cascade,
    constraint course_tags_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_topics (
    topic_id bigint not null,
    course_id bigint not null,
    constraint course_topics_topic_id_fkey foreign key (topic_id) references topics (id) on delete cascade,
    constraint course_topics_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_instructor (
    course_id bigint not null,
    user_id uuid not null,
    constraint course_instructor_pkey primary key (course_id, user_id),
    constraint course_instructor_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint course_instructor_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.enrollment (
    course_id bigint generated by default as identity not null,
    user_id uuid not null,
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    constraint enrollment_pkey primary key (course_id, user_id),
    constraint enrollment_id_key unique (id),
    constraint enrollment_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint enrollment_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_review (
    id bigint generated by default as identity not null,
    rating real not null,
    user_id uuid not null,
    course_id bigint not null,
    body text not null,
    created_at timestamp with time zone null default now(),
    constraint course_review_pkey primary key (id),
    constraint course_review_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade,
    constraint course_review_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint course_review_user_id_and_course_id_composite_key unique (user_id, course_id)
  ) tablespace pg_default;

-- views

create or replace view courses_sm as
select courses.id, category.name as category, sub_category.name as sub_category, courses.avg_rating, courses.language, courses.is_paid, courses.level, topics.name as topic
from
  courses
  join category on category.id = courses.category
  join sub_category on sub_category.id = courses.sub_category
  join course_topics on course_topics.course_id = courses.id
  join topics on topics.id = course_topics.topic_id;

create or replace view courses_md as
select courses.id, courses.image, courses.title, courses.short_description, category.name as category, sub_category.name as sub_category, user_profile.username as instructor, courses.avg_rating, count(distinct enrollment.id) as enrollment, courses.is_paid, courses.level, price.amount as amount, tags.name as tag, topics.name as topic
from
  courses
  join category on category.id = courses.category
  join sub_category on sub_category.id = courses.sub_category
  join course_instructor on course_instructor.course_id = courses.id
  join user_profile on course_instructor.user_id = user_profile.user_id
  join course_tags on course_tags.course_id = courses.id
  join tags on tags.id = course_tags.tag_id
  join course_topics on course_topics.course_id = courses.id
  join enrollment on enrollment.course_id = courses.id
  join price on price.course_id = courses.id
  join topics on topics.id = course_topics.topic_id
group by
  courses.id, category.name, sub_category.name, user_profile.username, price.amount, tags.name, topics.name;

-- function

create or replace function update_average_rating()
returns trigger as 
$$
declare avg_ratingx decimal(10, 2);
begin
    select AVG(rating) into avg_ratingx
    from course_review
    where course_id = NEW.course_id;
    
    update courses
    set avg_rating = avg_ratingx
    where id = NEW.course_id;

    return NEW;

end;
$$ language plpgsql;

create or replace function public.create_user(
    user_id uuid,
    username text,
    email text,
    password text,
    avatar text,
    first_name text,
    last_name text,
    account_type text
) returns void as $$
  declare
  encrypted_pw text;
begin
  encrypted_pw := crypt(password, gen_salt('bf'));
  
  insert into auth.users
    (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, recovery_token, recovery_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at)
  values
    ('00000000-0000-0000-0000-000000000000', user_id, 'authenticated', 'authenticated', email, encrypted_pw, '2023-05-03 19:41:43.585805+00', '', '2023-04-22 13:10:03.275387+00', '2023-04-22 13:10:31.458239+00', '{"provider":"email","providers":["email"]}', '{}', '2023-05-03 19:41:43.580424+00', '2023-05-03 19:41:43.585948+00');
  
  insert into auth.identities (id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at)
  values
    (user_id, user_id, format('{"sub":"%s","email":"%s"}', user_id::text, email)::jsonb, 'email', '2023-05-03 19:41:43.582456+00', '2023-05-03 19:41:43.582497+00', '2023-05-03 19:41:43.582497+00');

  insert into public.user_profile (user_id, username, avatar, first_name, last_name, account_type) VALUES (user_id, username, avatar, first_name, last_name, account_type);
end;
$$ language plpgsql;

create or replace function get_category_filters(
  categories text[],
  sub_categories text[],
  topics text[],
  levels text[],
  rating numeric,
  languages text[],
  price text[]
) returns json as
$$
declare
  filteredcourses bigint[];
  response json;
begin

  if topics is not null then
    select array(select
      id
    from
      courses_sm
    where
      (categories is null or category in (SELECT unnest(categories)))
      AND (sub_categories is null or sub_category in (select unnest(sub_categories)))
      AND (levels is null or level in (select unnest(levels)))
      AND (rating is null or avg_rating >= rating)
      AND (languages is null or language in (select unnest(languages)))
      AND (price is null or is_paid in (select unnest(price)))
      AND (topics is null or topic in (select unnest(topics)))
    group by
      id
    having
      COUNT(topic) = array_length(topics, 1)) into filteredcourses;
  else 
    select array(select
      id
    from
      courses_sm
    where
      (categories is null or category in (SELECT unnest(categories)))
      AND (sub_categories is null or sub_category in (select unnest(sub_categories)))
      AND (levels is null or level in (select unnest(levels)))
      AND (rating is null or avg_rating >= rating)
      AND (languages is null or language in (select unnest(languages)))
      AND (price is null or is_paid in (select unnest(price)))
    group by
      id) into filteredcourses;
  end if;

  select json_build_object (
    'grouped', 
    (select json_agg(row_to_json(t))
      from (select
        category, 
        COUNT(distinct case when avg_rating >= 3 then id end) as rating_3_up, 
        COUNT(distinct case when avg_rating >= 3.5 then id end) as rating_3_half_up, 
        COUNT(distinct case when avg_rating >= 4 then id end) as rating_4_up, 
        COUNT(distinct case when avg_rating >= 4.5 then id end) as rating_4_half_up, 
        COUNT(distinct case when is_paid = 'PAID' then id end) as paid, 
        COUNT(distinct case when is_paid = 'FREE' then id end) as free, 
        COUNT(distinct case when level = 'ALL_LEVELS' then id end) as all_levels, 
        COUNT(distinct case when level = 'BEGINNER' then id end) as beginner, 
        COUNT(distinct case when level = 'INTERMEDIATE' then id end) as intermediate, 
        COUNT(distinct case when level = 'EXPERT' then id end) as expert
      from 
        courses_sm
      where
        id in (select unnest(filteredcourses))
      group by
        category) t
    ),
    'topics',
    (
      select json_agg(row_to_json(t))
      from (
        select
          topic, 
          COUNT(distinct id) as topic_count
        from 
          courses_sm
        where
          id in (select unnest(filteredcourses))
        group by
          topic
        order by topic_count desc
        limit 20
      ) t
    ),
    'sub_category',
    (
      select json_agg(row_to_json(t))
      from (
        select
          sub_category, 
          COUNT(distinct id) as sub_category_count
        from 
          courses_sm
        where
          id in (select unnest(filteredcourses))
        group by
          sub_category
        order by sub_category_count desc
      ) t
    )
  ) into response;

  return response;
end;
$$
language plpgsql;

-- triggers

create trigger update_average_rating_trigger
after insert on course_review
for each row
execute procedure update_average_rating();