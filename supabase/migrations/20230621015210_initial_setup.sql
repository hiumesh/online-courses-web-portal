-- types

create type course_level_enum as enum ('ALL_LEVELS', 'BEGINNER', 'INTERMEDIATE', 'EXPERT');
create type course_access_enum as enum ('PAID', 'FREE');
create type language_enum AS enum ('English', 'Hindi', 'Sanskrit', 'Spanish', 'French', 'German', 'Italian', 'Japanese', 'Chinese', 'Russian', 'Other');

-- tables

create table
  public.user_profile (
    user_id uuid not null,
    username text not null,
    avatar text null,
    first_name text null,
    last_name text null,
    account_type text not null default 'default'::text,
    constraint user_profile_pkey primary key (user_id),
    constraint user_profile_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.category (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    created_at timestamp with time zone null default now(),
    constraint category_pkey primary key (id),
    constraint category_name_key unique (name)
  ) tablespace pg_default;

create table
  public.sub_category (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    category_id bigint not null,
    created_at timestamp with time zone null default now(),
    constraint sub_category_pkey primary key (id),
    constraint sub_category_name_and_category_id_composite_key unique (name, category_id),
    constraint sub_category_category_id_fkey foreign key (category_id) references category (id) on delete cascade
  ) tablespace pg_default;

create table
  public.topics (
    id bigint generated by default as identity not null,
    name text not null,
    description text null,
    created_at timestamp with time zone null default now(),
    constraint topics_pkey primary key (id),
    constraint topics_name_key unique (name)
  ) tablespace pg_default;


create table
  public.sub_category_topics (
    topic_id bigint not null,
    sub_category_id bigint not null,
    constraint sub_category_topics_pkey primary key(topic_id, sub_category_id),
    constraint sub_category_topics_topic_id_fkey foreign key (topic_id) references topics (id) on delete cascade,
    constraint sub_category_topics_sub_category_id_fkey foreign key (sub_category_id) references sub_category (id) on delete cascade
  ) tablespace pg_default;


create table
  public.topic_connections (
    id bigint generated by default as identity not null,
    from_id bigint not null,
    to_id bigint not null,
    constraint topic_connections_pkey primary key(id),
    constraint topic_connections_from_and_to_key unique(from_id, to_id),
    constraint topic_connections_from_id_fkey foreign key (from_id) references topics (id) on delete cascade,
    constraint topic_connections_to_id_fkey foreign key (to_id) references topics (id) on delete cascade
  ) tablespace pg_default;

create table
  public.courses (
    id bigint generated by default as identity not null,
    image text null,
    title text not null,
    short_description text null,
    category bigint not null,
    sub_category bigint not null,
    level course_level_enum default 'ALL_LEVELS' not null,
    long_description text null,
    requirements text null,
    course_purpose text null,
    language language_enum not null,
    is_paid course_access_enum default 'PAID' not null,
    course_promises json null,
    avg_rating decimal(10,2) default 0 not null,
    review_count bigint default 0 not null,
    enrollment_count bigint default 0 not null,
    created_at timestamp with time zone null default now(),
    updated_at timestamp with time zone null default now(),
    constraint courses_pkey primary key (id),
    constraint courses_category_fkey foreign key (category) references category (id) on delete restrict,
    constraint courses_sub_category_fkey foreign key (sub_category) references sub_category (id) on delete restrict
  ) tablespace pg_default;

create table
  public.price (
    id bigint generated by default as identity not null,
    course_id bigint not null,
    amount decimal(10,2),
    currency varchar(3) default 'USD',
    is_promotional boolean default false,
    start_date date,
    end_date date,
    constraint price_pkey primary key (id),
    constraint price_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.tags (
    id bigint generated by default as identity not null,
    name text not null,
    constraint tags_pkey primary key (id),
    constraint tags_name_key unique (name)
  ) tablespace pg_default;

create table
  public.course_tags (
    tag_id bigint not null,
    course_id bigint not null,
    constraint course_tags_tag_id_fkey foreign key (tag_id) references tags (id) on delete cascade,
    constraint course_tags_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_topics (
    topic_id bigint not null,
    course_id bigint not null,
    constraint course_topics_topic_id_fkey foreign key (topic_id) references topics (id) on delete cascade,
    constraint course_topics_course_id_fkey foreign key (course_id) references courses (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_instructor (
    course_id bigint not null,
    user_id uuid not null,
    constraint course_instructor_pkey primary key (course_id, user_id),
    constraint course_instructor_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint course_instructor_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.enrollment (
    course_id bigint generated by default as identity not null,
    user_id uuid not null,
    id bigint generated by default as identity not null,
    created_at timestamp with time zone null default now(),
    constraint enrollment_pkey primary key (course_id, user_id),
    constraint enrollment_id_key unique (id),
    constraint enrollment_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint enrollment_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade
  ) tablespace pg_default;

create table
  public.course_review (
    id bigint generated by default as identity not null,
    rating real not null,
    user_id uuid not null,
    course_id bigint not null,
    body text not null,
    created_at timestamp with time zone null default now(),
    constraint course_review_pkey primary key (id),
    constraint course_review_user_id_fkey foreign key (user_id) references auth.users (id) on delete cascade,
    constraint course_review_course_id_fkey foreign key (course_id) references courses (id) on delete cascade,
    constraint course_review_user_id_and_course_id_composite_key unique (user_id, course_id)
  ) tablespace pg_default;


-- indexs

create index idx_search_courses on courses using gin(to_tsvector('english', title || ' ' || short_description));

-- views

create or replace view courses_sm as
select courses.id, courses.title, courses.short_description, category.name as category, sub_category.name as sub_category, courses.avg_rating, courses.language, courses.is_paid, courses.level, json_agg(topics.name) as topic
from
  courses
  join category on category.id = courses.category
  join sub_category on sub_category.id = courses.sub_category
  join course_topics on course_topics.course_id = courses.id
  join topics on topics.id = course_topics.topic_id
group by
  courses.id, category.name, sub_category.name;

create or replace view courses_md as
select courses.id, courses.image, courses.title, courses.short_description, courses.enrollment_count, courses.created_at, category.name as category, sub_category.name as sub_category, courses.avg_rating, courses.is_paid, courses.level, price.amount as amount,  courses.language, courses.review_count, json_agg(distinct tags.name) as tag, json_agg(distinct topics.name) as topic, json_agg(distinct user_profile.username) as instructor
from
  courses
  join category on category.id = courses.category
  join sub_category on sub_category.id = courses.sub_category
  left join price on price.course_id = courses.id
  left join course_tags on course_tags.course_id = courses.id
  left join tags on tags.id = course_tags.tag_id
  join course_instructor on course_instructor.course_id = courses.id
  join user_profile on course_instructor.user_id = user_profile.user_id
  join course_topics on course_topics.course_id = courses.id
  join topics on topics.id = course_topics.topic_id
group by
  courses.id, category.id, sub_category.id, price.id;

-- function

create or replace function update_average_rating()
returns trigger as 
$$
declare avg_ratingx decimal(10, 2);
decimal review_countx bigint;
begin
    select AVG(rating), COUNT(id) into avg_ratingx, review_countx
    from course_review
    where course_id = NEW.course_id;
    
    update courses
    set avg_rating = avg_ratingx, review_count = review_countx
    where id = NEW.course_id;

    return NEW;

end;
$$ language plpgsql;

create or replace function update_enrollment_count()
returns trigger as
$$
declare enroll_count bigint;
begin
  select COUNT(user_id) into enroll_count
  from enrollment
  where course_id = NEW.course_id;

  update courses
  set enrollment_count = enroll_count
  where id = NEW.course_id;

  return NEW;
end;
$$ language plpgsql;

create or replace function public.create_user(
    user_id uuid,
    username text,
    email text,
    password text,
    avatar text,
    first_name text,
    last_name text,
    account_type text
) returns void as $$
  declare
  encrypted_pw text;
begin
  encrypted_pw := crypt(password, gen_salt('bf'));
  
  insert into auth.users
    (instance_id, id, aud, role, email, encrypted_password, email_confirmed_at, recovery_token, recovery_sent_at, last_sign_in_at, raw_app_meta_data, raw_user_meta_data, created_at, updated_at)
  values
    ('00000000-0000-0000-0000-000000000000', user_id, 'authenticated', 'authenticated', email, encrypted_pw, '2023-05-03 19:41:43.585805+00', '', '2023-04-22 13:10:03.275387+00', '2023-04-22 13:10:31.458239+00', '{"provider":"email","providers":["email"]}', '{}', '2023-05-03 19:41:43.580424+00', '2023-05-03 19:41:43.585948+00');
  
  insert into auth.identities (id, user_id, identity_data, provider, last_sign_in_at, created_at, updated_at)
  values
    (user_id, user_id, format('{"sub":"%s","email":"%s"}', user_id::text, email)::jsonb, 'email', '2023-05-03 19:41:43.582456+00', '2023-05-03 19:41:43.582497+00', '2023-05-03 19:41:43.582497+00');

  insert into public.user_profile (user_id, username, avatar, first_name, last_name, account_type) VALUES (user_id, username, avatar, first_name, last_name, account_type);
end;
$$ language plpgsql;

create or replace function get_text_search_filters(
  q text,
  topics text[],
  levels course_level_enum[],
  rating numeric,
  languages language_enum[],
  price course_access_enum[]
) returns json as
$$
declare
  response json;
begin
  select json_build_object (
    'total', 
    (
      select row_to_json(t)
      from (
        select
          COUNT(distinct id) as total_count
        from 
          courses_sm sm
        where
          to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
          AND (levels is null or level in (select unnest(levels)))
          AND (rating is null or avg_rating >= rating)
          AND (languages is null or language in (select unnest(languages)))
          AND (price is null or is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
        
      ) t
    ),
    'ratings',
    (
      select row_to_json(t)
      from (select
        COUNT(distinct case when avg_rating >= 3 then id end) as rating_3_up, 
        COUNT(distinct case when avg_rating >= 3.5 then id end) as rating_3_half_up, 
        COUNT(distinct case when avg_rating >= 4 then id end) as rating_4_up, 
        COUNT(distinct case when avg_rating >= 4.5 then id end) as rating_4_half_up
      from 
        courses_sm sm
      where
        to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
        AND (levels is null or level in (select unnest(levels)))
        AND (languages is null or language in (select unnest(languages)))
        AND (price is null or is_paid in (select unnest(price)))
        AND (topics is null or topic::jsonb ?& topics)
      ) t
    ),
    'paid',
    (
      select row_to_json(t)
      from (select
        COUNT(distinct case when is_paid = 'PAID' then id end) as paid, 
        COUNT(distinct case when is_paid = 'FREE' then id end) as free
      from 
        courses_sm sm
      where
        to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
        AND (levels is null or level in (select unnest(levels)))
        AND (rating is null or avg_rating >= rating)
        AND (languages is null or language in (select unnest(languages)))
        AND (topics is null or topic::jsonb ?& topics)
      ) t
    ),
    'level',
    (
      select row_to_json(t)
      from (select
        COUNT(distinct case when level = 'ALL_LEVELS' then id end) as all_levels, 
        COUNT(distinct case when level = 'BEGINNER' then id end) as beginner, 
        COUNT(distinct case when level = 'INTERMEDIATE' then id end) as intermediate, 
        COUNT(distinct case when level = 'EXPERT' then id end) as expert
      from 
        courses_sm sm
      where
        to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
        AND (rating is null or avg_rating >= rating)
        AND (languages is null or language in (select unnest(languages)))
        AND (price is null or is_paid in (select unnest(price)))
        AND (topics is null or topic::jsonb ?& topics)
      ) t
    ),
    'topics',
    (
      select json_agg(row_to_json(t))
      from (
        select
          json_array_elements_text(topic) as topic_name,
          count(distinct id) as topic_count
        from 
          courses_sm sm
        where
          to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
          AND (levels is null or level in (select unnest(levels)))
          AND (rating is null or avg_rating >= rating)
          AND (languages is null or language in (select unnest(languages)))
          AND (price is null or is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
        group by
          topic_name
        order by topic_count desc
        limit 20
      ) t
    ),
    'languages',
    (
      select json_agg(row_to_json(t))
      from (
        select
          language as language_name,
          count(distinct id) as language_count
        from 
          courses_sm sm
        where
          to_tsvector('english', title || ' ' || short_description) @@ to_tsquery('english', q)
          AND (levels is null or level in (select unnest(levels)))
          AND (rating is null or avg_rating >= rating)
          AND (price is null or is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
        group by
          language
        order by language_count desc
        limit 20
      ) t
    ) 
    
  ) into response;

  return response;
end;
$$
language plpgsql;

create or replace function get_category_filters(
  categories text[],
  sub_categories text[],
  topics text[],
  levels course_level_enum[],
  rating numeric,
  languages language_enum[],
  price course_access_enum[],
  sort text
) returns json as
$$
declare
  filteredcourses bigint[];
  response json;
begin

  if topics is not null then
    select array(select
      id
    from
      courses_sm
    where
      (categories is null or category in (SELECT unnest(categories)))
      AND (sub_categories is null or sub_category in (select unnest(sub_categories)))
      AND (levels is null or level in (select unnest(levels)))
      AND (rating is null or avg_rating >= rating)
      AND (languages is null or language in (select unnest(languages)))
      AND (price is null or is_paid in (select unnest(price)))
      AND (topics is null or topic in (select unnest(topics)))
    group by
      id
    having
      COUNT(topic) = array_length(topics, 1)) into filteredcourses;
  else 
    select array(select
      id
    from
      courses_sm
    where
      (categories is null or category in (SELECT unnest(categories)))
      AND (sub_categories is null or sub_category in (select unnest(sub_categories)))
      AND (levels is null or level in (select unnest(levels)))
      AND (rating is null or avg_rating >= rating)
      AND (languages is null or language in (select unnest(languages)))
      AND (price is null or is_paid in (select unnest(price)))
    group by
      id) into filteredcourses;
  end if;

  select json_build_object (
    'grouped', 
    (select json_agg(row_to_json(t))
      from (select
        category,
        COUNT(distinct id) as total_count,
        COUNT(distinct case when avg_rating >= 3 then id end) as rating_3_up, 
        COUNT(distinct case when avg_rating >= 3.5 then id end) as rating_3_half_up, 
        COUNT(distinct case when avg_rating >= 4 then id end) as rating_4_up, 
        COUNT(distinct case when avg_rating >= 4.5 then id end) as rating_4_half_up, 
        COUNT(distinct case when is_paid = 'PAID' then id end) as paid, 
        COUNT(distinct case when is_paid = 'FREE' then id end) as free, 
        COUNT(distinct case when level = 'ALL_LEVELS' then id end) as all_levels, 
        COUNT(distinct case when level = 'BEGINNER' then id end) as beginner, 
        COUNT(distinct case when level = 'INTERMEDIATE' then id end) as intermediate, 
        COUNT(distinct case when level = 'EXPERT' then id end) as expert
      from 
        courses_sm
      where
        id in (select unnest(filteredcourses))
      group by
        category) t
    ),
    'topics',
    (
      select json_agg(row_to_json(t))
      from (
        select
          topic, 
          COUNT(distinct id) as topic_count
        from 
          courses_sm
        where
          id in (select unnest(filteredcourses))
        group by
          topic
        order by topic_count desc
        limit 20
      ) t
    ),
    'sub_category',
    (
      select json_agg(row_to_json(t))
      from (
        select
          sub_category, 
          COUNT(distinct id) as sub_category_count
        from 
          courses_sm
        where
          id in (select unnest(filteredcourses))
        group by
          sub_category
        order by sub_category_count desc
      ) t
    )
  ) into response;

  return response;
end;
$$
language plpgsql;

create or replace function get_courses_list(
  q text,
  categories text[],
  sub_categories text[],
  topics text[],
  levels course_level_enum[],
  rating numeric,
  languages language_enum[],
  price course_access_enum[],
  sort text,
  page_size integer,
  p integer
) returns table (
  id bigint,
  image text,
  title text,
  short_description text,
  enrollment_count bigint,
  instructors json,
  tags json,
  is_paid course_access_enum,
  avg_rating decimal(10,2),
  review_count bigint,
  level course_level_enum,
  amount decimal(10,2)
) as
$$
declare
  response json;
begin

  if sort = 'mostpop' then
      return query select c.id, c.image, c.title, c.short_description, c.enrollment_count, c.instructor as instructors, c.tag as tags, c.is_paid, c.avg_rating, c.review_count, c.level, c.amount
      from
        courses_md c
      where
          (q is null or to_tsvector('english', c.title || ' ' || c.short_description) @@ to_tsquery('english', q))
          AND (categories is null or c.category in (SELECT unnest(categories)))
          AND (sub_categories is null or c.sub_category in (select unnest(sub_categories)))
          AND (levels is null or c.level in (select unnest(levels)))
          AND (rating is null or c.avg_rating >= rating)
          AND (languages is null or c.language in (select unnest(languages)))
          AND (price is null or c.is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
      order by
        c.enrollment_count desc,
        c.id
      limit page_size
      offset page_size * p;
  elseif sort = 'new' then
      return query select c.id, c.image, c.title, c.short_description, c.enrollment_count, c.instructor as instructors, c.tag as tags, c.is_paid, c.avg_rating, c.review_count, c.level, c.amount
      from
        courses_md c
      where
          (q is null or to_tsvector('english', c.title || ' ' || c.short_description) @@ to_tsquery('english', q))
          AND (categories is null or c.category in (SELECT unnest(categories)))
          AND (sub_categories is null or c.sub_category in (select unnest(sub_categories)))
          AND (levels is null or c.level in (select unnest(levels)))
          AND (rating is null or c.avg_rating >= rating)
          AND (languages is null or c.language in (select unnest(languages)))
          AND (price is null or c.is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
      order by
        c.created_at desc,
        c.id
      limit page_size
      offset page_size * p;
  elseif sort = 'high' then
      return query select c.id, c.image, c.title, c.short_description, c.enrollment_count, c.instructor as instructors, c.tag as tags, c.is_paid, c.avg_rating, c.review_count, c.level, c.amount
      from
        courses_md c
      where
          (q is null or to_tsvector('english', c.title || ' ' || c.short_description) @@ to_tsquery('english', q))
          AND (categories is null or c.category in (SELECT unnest(categories)))
          AND (sub_categories is null or c.sub_category in (select unnest(sub_categories)))
          AND (levels is null or c.level in (select unnest(levels)))
          AND (rating is null or c.avg_rating >= rating)
          AND (languages is null or c.language in (select unnest(languages)))
          AND (price is null or c.is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
      order by
        c.avg_rating desc,
        c.id
      limit page_size
      offset page_size * p;
  else
     return query select c.id, c.image, c.title, c.short_description, c.enrollment_count, c.instructor as instructors, c.tag as tags, c.is_paid, c.avg_rating, c.review_count, c.level, c.amount
      from
        courses_md c
      where
          (q is null or to_tsvector('english', c.title || ' ' || c.short_description) @@ to_tsquery('english', q))
          AND (categories is null or c.category in (SELECT unnest(categories)))
          AND (sub_categories is null or c.sub_category in (select unnest(sub_categories)))
          AND (levels is null or c.level in (select unnest(levels)))
          AND (rating is null or c.avg_rating >= rating)
          AND (languages is null or c.language in (select unnest(languages)))
          AND (price is null or c.is_paid in (select unnest(price)))
          AND (topics is null or topic::jsonb ?& topics)
      order by
        c.id
      limit page_size
      offset page_size * p;
  end if;  
end;
$$
language plpgsql;

-- triggers

create trigger update_average_rating_trigger
after insert on course_review
for each row
execute procedure update_average_rating();

create trigger update_enrollment_count_trigger
after insert on enrollment
for each row
execute procedure update_enrollment_count();